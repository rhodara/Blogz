<html><body><pre>// populdlg.cpp : implementation file//#include "stdafx.h"#include "population.h"#include "populdlg.h"#include "apstring.cpp"#include "apvector.cpp"#include "apmatrix.cpp"#include "stdlib.h"#include "stdio.h"#include "Random.h"	// custom random generator#include "rando.cpp"#include "Punnet.h"	// custom genetic square cross generator//#include "Sort.h"	// QuickSort, SelectSort.  used in death()#include "math.h"#include <ctype.h>  #ifdef _DEBUG#undef THIS_FILEstatic char BASED_CODE THIS_FILE[] = __FILE__;#endif/////////////////////////////////////////////////////////////////////////////// CAboutDlg dialog used for App Aboutclass CAboutDlg : public CDialog{public:	CAboutDlg();// Dialog Data	//{{AFX_DATA(CAboutDlg)	enum { IDD = IDD_ABOUTBOX };	//}}AFX_DATA// Implementationprotected:	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support	//{{AFX_MSG(CAboutDlg)	virtual BOOL OnInitDialog();	//}}AFX_MSG	DECLARE_MESSAGE_MAP()};CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD){	//{{AFX_DATA_INIT(CAboutDlg)	//}}AFX_DATA_INIT}void CAboutDlg::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CAboutDlg)	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)	//{{AFX_MSG_MAP(CAboutDlg)		// No message handlers	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CAboutDlg message handlersBOOL CAboutDlg::OnInitDialog(){	CDialog::OnInitDialog();	CenterWindow();		// TODO: Add extra about dlg initialization here		return TRUE;  // return TRUE  unless you set the focus to a control}/////////////////////////////////////////////////////////////////////////////// CPopulationDlg dialogapmatrix<int>pop(100,100);apmatrix<int>pop2(100,100);apmatrix<int>age(100,100);apmatrix<apstring>trait(100,100);apmatrix<int>sex(100,100);apvector<int>ages(10000);CString GENO[4];int iGENO[4];RandGen(rnd);//Random rnd(ran.RandInt(1234567,7654321));Punnet pun;//Sort   srt();CPopulationDlg::CPopulationDlg(CWnd* pParent /*=NULL*/)	: CDialog(CPopulationDlg::IDD, pParent){	//{{AFX_DATA_INIT(CPopulationDlg)	m_TOTAL = 0;	m_GENO1 = _T("");	m_GENO1T = 0;	m_GENO2 = _T("");	m_GENO2T = 0;	m_GENO3 = _T("");	m_GENO3T = 0;	m_GRID = 0;	m_MOVE = FALSE;	m_CAPACITY = 0;	m_ageLimit = 0;	m_mature = 0;	m_grid = FALSE;	m_counter = 0;	m_RECDIE = 0;	m_KILLMOM = FALSE;	m_NODIFFERENT = TRUE;	m_STERILE = FALSE;	m_DIEATBIRTH = FALSE;	m_DIEAFTER = FALSE;	m_OLD = 0;	m_EDGE = FALSE;	m_INCUBATION = 0;	m_RESTART = TRUE;	m_AVAGE = 0.0;	//}}AFX_DATA_INIT	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);}void CPopulationDlg::DoDataExchange(CDataExchange* pDX){	CDialog::DoDataExchange(pDX);	//{{AFX_DATA_MAP(CPopulationDlg)	DDX_Text(pDX, IDC_EDIT_TOTAL, m_TOTAL);	DDX_Text(pDX, IDC_EDIT_GENO1, m_GENO1);	DDX_Text(pDX, IDC_EDIT_GENO1T, m_GENO1T);	DDX_Text(pDX, IDC_EDIT_GENO2, m_GENO2);	DDX_Text(pDX, IDC_EDIT_GENO2T, m_GENO2T);	DDX_Text(pDX, IDC_EDIT_GENO3, m_GENO3);	DDX_Text(pDX, IDC_EDIT_GENO3T, m_GENO3T);	DDX_Text(pDX, IDC_EDIT_GRID_SIZE, m_GRID);	DDX_Check(pDX, IDC_MIGRATION, m_MOVE);	DDX_Text(pDX, IDC_EDIT_CAPACITY, m_CAPACITY);	DDX_Text(pDX, IDC_EDIT_LIFESPAN, m_ageLimit);	DDX_Text(pDX, IDC_EDIT_MATURE, m_mature);	DDX_Check(pDX, IDC_GRID, m_grid);	DDX_Text(pDX, IDC_EDIT_COUNTER, m_counter);	DDX_Text(pDX, IDC_EDIT_REC_DIE, m_RECDIE);	DDX_Check(pDX, IDC_KILL_MOM, m_KILLMOM);	DDX_Check(pDX, IDC_NODIFFERENT, m_NODIFFERENT);	DDX_Check(pDX, IDC_STERILE, m_STERILE);	DDX_Check(pDX, IDC_DIE_AT_BIRTH, m_DIEATBIRTH);	DDX_Check(pDX, IDC_DIE_AFTER, m_DIEAFTER);	DDX_Text(pDX, IDC_EDIT_OLD, m_OLD);	DDX_Check(pDX, IDC_EDGE, m_EDGE);	DDX_Text(pDX, IDC_EDIT_INCUBATION, m_INCUBATION);	DDX_Text(pDX, IDC_EDIT_AV_AGE, m_AVAGE);	//}}AFX_DATA_MAP}BEGIN_MESSAGE_MAP(CPopulationDlg, CDialog)	//{{AFX_MSG_MAP(CPopulationDlg)	ON_WM_SYSCOMMAND()	ON_WM_PAINT()	ON_WM_QUERYDRAGICON()	ON_COMMAND(ID_FILE_EXIT, OnFileExit)	ON_COMMAND(ID_FILE_GO, OnFileGo)	ON_WM_TIMER()	ON_COMMAND(ID_FILE_STOP, OnFileStop)	ON_COMMAND(ID_FILE_CLEAR, OnFileClear)	ON_COMMAND(ID_FILE_NEXT, OnFileNext)	ON_COMMAND(ID_FILE_RANDOMNEW, OnFileRandomnew)	ON_COMMAND(ID_ACTION_GRIDOFF, OnActionGridoff)	ON_COMMAND(ID_ACTION_GRIDON, OnActionGridon)	ON_COMMAND(ID_VIEW_SHOWTOTAL, OnViewShowtotal)	ON_BN_CLICKED(IDC_BUTTON_NEXT, OnButtonNext)	ON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStop)	ON_BN_CLICKED(IDC_BUTTON_GO, OnButtonGo)	ON_BN_CLICKED(IDC_MIGRATION, OnMigration)	ON_EN_CHANGE(IDC_EDIT_GRID_SIZE, OnChangeEditGridSize)	ON_BN_CLICKED(IDC_GRID, OnGrid)	ON_EN_CHANGE(IDC_EDIT_CAPACITY, OnChangeEditCapacity)	ON_EN_CHANGE(IDC_EDIT_MATURE, OnChangeEditMature)	ON_EN_CHANGE(IDC_EDIT_LIFESPAN, OnChangeEditLifespan)	ON_BN_CLICKED(IDC_KILL_MOM, OnKillMom)	ON_BN_CLICKED(IDC_NODIFFERENT, OnNodifferent)	ON_BN_CLICKED(IDC_STERILE, OnSterile)	ON_EN_CHANGE(IDC_EDIT_REC_DIE, OnChangeEditRecDie)	ON_BN_CLICKED(IDC_DIE_AT_BIRTH, OnDieAtBirth)	ON_BN_CLICKED(IDC_DIE_AFTER, OnDieAfter)	ON_EN_CHANGE(IDC_EDIT_OLD, OnChangeEditOld)	ON_BN_CLICKED(IDC_EDGE, OnEdge)	ON_EN_CHANGE(IDC_EDIT_INCUBATION, OnChangeEditIncubation)	//}}AFX_MSG_MAPEND_MESSAGE_MAP()/////////////////////////////////////////////////////////////////////////////// CPopulationDlg message handlersBOOL CPopulationDlg::OnInitDialog(){	CDialog::OnInitDialog();	CenterWindow();	// Add "About..." menu item to system menu.	// IDM_ABOUTBOX must be in the system command range.	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);	ASSERT(IDM_ABOUTBOX < 0xF000);	CMenu* pSysMenu = GetSystemMenu(FALSE);	CString strAboutMenu;	strAboutMenu.LoadString(IDS_ABOUTBOX);	if (!strAboutMenu.IsEmpty())	{		pSysMenu->AppendMenu(MF_SEPARATOR);		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);	}		// TODO: Add extra initialization here//	m_sizex = 50;//	m_sizey = 50;	m_timer = FALSE;	m_grid = TRUE;	m_ageLimit = 15;	m_OLD = 12;	m_mature = 2;	m_GRID = 2500;	m_sizex = (int) sqrt(m_GRID);	m_sizey = (int) sqrt(m_GRID);	m_zoom = (int) (300 / (sqrt(m_GRID)));	m_counter = 0;	m_CAPACITY = (int) (m_GRID / 3);	m_INCUBATION = 0;	OnSterile();	UpdateData(FALSE);	return TRUE;  // return TRUE  unless you set the focus to a control}void CPopulationDlg::OnSysCommand(UINT nID, LPARAM lParam){	if ((nID & 0xFFF0) == IDM_ABOUTBOX)	{		CAboutDlg dlgAbout;		dlgAbout.DoModal();	}	else	{		CDialog::OnSysCommand(nID, lParam);	}}// If you add a minimize button to your dialog, you will need the code below//  to draw the icon.  For MFC applications using the document/view model,//  this is automatically done for you by the framework.void CPopulationDlg::OnPaint() {	if (IsIconic())	{		CPaintDC dc(this); // device context for painting		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);		// Center icon in client rectangle		int cxIcon = GetSystemMetrics(SM_CXICON);		int cyIcon = GetSystemMetrics(SM_CYICON);		CRect rect;		GetClientRect(&rect);		int x = (rect.Width() - cxIcon + 1) / 2;		int y = (rect.Height() - cyIcon + 1) / 2;		// Draw the icon		dc.DrawIcon(x, y, m_hIcon);	}	else	{		CDialog::OnPaint();	}}// The system calls this to obtain the cursor to display while the user drags//  the minimized window.HCURSOR CPopulationDlg::OnQueryDragIcon(){	return (HCURSOR) m_hIcon;}void CPopulationDlg::OnFileExit() {																		   //ok	KillTimer(1);	OnOK();	}void CPopulationDlg::OnFileGo() 									   //ok{	if (m_RESTART)		OnFileRandomnew();	if (m_timer == TRUE)		KillTimer(1);	// Install a system timer	int iInstallResult;	iInstallResult = SetTimer(1,500,NULL);	if (iInstallResult == 0)		MessageBox("cannot install timer!");	else		m_timer = TRUE;}void CPopulationDlg::DrawBox(int fy,int fx,int c1,int c2,int c3)   //ok{	CClientDC dc(this);	for(int i=0;i<m_zoom;i++)	{		for(int j=0;j<m_zoom;j++){			dc.SetPixel(10+(m_zoom+1)*fy+i,10+(m_zoom+1)*fx+j,RGB(c1,c2,c3));		}	}}void CPopulationDlg::DrawGrid()								  //ok{	CClientDC dc(this);	dc.SetPixel(9,9,RGB(0,0,0));	int i,j;	for(j=0;j<=m_sizex;j++)	{		for(i=0;i<=m_sizey;i++)		{			dc.MoveTo(9+(m_zoom+1)*i,9+(m_zoom+1)*j);			dc.LineTo(9+(m_zoom+1)*m_sizey,9+(m_zoom+1)*j);			dc.MoveTo(9+(m_zoom+1)*i,9+(m_zoom+1)*j);			dc.LineTo(9+(m_zoom+1)*i,9+(m_zoom+1)*m_sizex);		}	}}	void CPopulationDlg::DrawPop()									  //ok{	for(int j=0;j<m_sizey;j++)	{		for(int i=0;i<m_sizex;i++)		{			if(pop[i] [j] == 0) // no cell present				DrawBox(i,j,255,255,255);			else if ((age [i] [j] <= m_mature) && (pop [i] [j] >= 1)) 	// immature				DrawBox(i,j,0,255,0);			else if ((age [i] [j] > m_OLD) && (pop [i] [j] >= 1)) 		// elderly				DrawBox(i,j,128,128,128);			else if ((sex [i] [j] > 1) && (pop [i] [j] >= 1)) 		// incubating				DrawBox(i,j,255,255,0);			else if ((trait [i] [j] == "rr") && (pop [i] [j] >= 1))		// recessive				DrawBox(i,j,255,0,0);			else if ((trait [i] [j] == "Rr") && (pop [i] [j] >= 1))		// carrier				DrawBox(i,j,128,0,128);			else if ((trait [i] [j] == "RR") && (pop [i] [j] >= 1))		// healthy				DrawBox(i,j,0,0,255);			else if (pop[i] [j] >= 1)				DrawBox(i,i,0,0,0);		}	}}void CPopulationDlg::ClearAll()			  //ok{	for(int j=0;j<m_sizex;j++)		for(int i=0;i<m_sizey;i++)			DrawBox(i,j,255,255,255);}void CPopulationDlg::UpdatePop() {		 //hmm....	int a,b;	m_counter++;	// kill old life	for(a=0; a < m_sizey;a++)        for(b=0;b<m_sizex;b++)			pop2 [a] [b] = pop [a] [b];	for(a=0; a < m_sizey;a++)        for(b=0;b<m_sizex;b++)			if ((age [a] [b] > m_ageLimit) 				|| ((pop2 [a] [b] == 2) && (m_DIEAFTER) && (age [a] [b] > m_RECDIE)))				KillCell(a,b);		Pop2ToPop();		int male;	int female;	for(a=0;a<m_sizey;a++) {        for(b=0;b<m_sizex;b++) {			if (pop2 [a] [b] == 0) {				male = 0;				female = 0;				if (a > 0)   	            	if( ((pop [a-1] [b]) > 0) && (age [a-1] [b] > m_mature) && (age [a-1] [b] < m_OLD)) // must be alive, and old enough to reproduce   	                	if (sex [a-1] [b] == 1)							male = 1;						else if (sex [a-1] [b] == 0)							female = 1;   		   	        if ((a > 0) && (b < (m_sizex)))   		        	if( ((pop [a-1] [b+1]) > 0) && (age [a-1] [b+1] > m_mature) && (age [a-1] [b+1] < m_OLD))   		            	if (sex [a-1] [b+1] == 1)							male = 1;						else if (sex [a-1] [b+1] == 0)							female = 1;	           if (b > 0)	   	            if( ((pop [a] [b-1]) > 0) && (age [a] [b-1] > m_mature) && (age [a] [b-1] < m_OLD))	                    if (sex [a] [b-1] == 1)							male = 1;						else if (sex [a] [b-1] == 0)							female = 1;			   	         if ((b > 0) && (a < (m_sizey)))  	 	             if( ((pop [a+1] [b-1]) > 0) && (age [a+1] [b-1] > m_mature) && (age [a+1] [b-1] < m_OLD))   		                 if (sex [a+1] [b-1] == 1)							male = 1;						else if (sex [a+1] [b-1] == 0)							female = 1; 	  	        if (a < (m_sizey)) 	            	if( ((pop [a+1] [b]) > 0) && (age [a+1] [b] > m_mature) && (age [a+1] [b] < m_OLD)) 	                	if (sex [a+1] [b] == 1)							male = 1;						else if (sex [a+1] [b] == 0)							female = 1;   		       	if ((a < (m_sizey)) && (b < (m_sizex)))   		        	if( ((pop [a+1] [b+1]) > 0) && (age [a+1] [b+1] > m_mature) && (age [a+1] [b+1] < m_OLD))	   	            	if (sex [a+1] [b+1] == 1)							male = 1;						else if (sex [a+1] [b+1] == 0)							female = 1;	            if (b < (m_sizex))                	if( ((pop [a] [b+1]) > 0) && (age [a] [b+1] > m_mature) && (age [a] [b+1] < m_OLD))                    	if (sex [a] [b+1] == 1)							male = 1;						else if (sex [a] [b+1] == 0)							female = 1;				if ((a > 0) && (b > 0))					if (((pop [a-1] [b-1]) > 0) && (age [a-1] [b-1] > m_mature) && (age [a-1] [b-1] < m_OLD))   	                	if (sex [a-1] [b-1] == 1)							male = 1;						else if (sex [a-1] [b-1] == 0)							female = 1;				if ((male == 1)	&& (female == 1))					GiveLife(a,b);        	}    	}	}		/* DO QUICKSORT TO ORGANIZE OLDEST TO YOUNGEST */	/* KILL OFF OLDEST UNTIL TOTAL <= CAPACITY */	// (1). arrange age matrix in a vector with only indexes of living cells.  	//		use type cell to store coordinates with age	// (2). quicksort this vector	// (3). Kill eldest, youngest, and pregnant cells until carrying capacity met	// (4). update the age matrix with dead cells	// 	// DEATH PRIORITIES:	// (1) non-reproducing elderly (start with oldest)	// (2) non-reproducing young (start with youngest)	// (3) pregnant females			int i,j,k;		if (m_EDGE) {  //	EDGE EFFECT.	(faster)		for(i=0;i<m_sizex * m_sizey;i++)			ages[i] = -1;		i=0;		for(j=0; j < m_sizey; j++)   	 	{	   	    for(k=0; k < m_sizex;k++)   		    {        	   	if (pop [j] [k] != 0)		   		{		   			ages [i] = age [j][k];        			i++;				}        	}    	}			int to_kill = i - m_CAPACITY - 1;		QSort(i);		i=0;		int m_CAPlimit,done=0,k;		while ((ages[i] != -1) && !(done))		{			if (i > m_CAPACITY) {				m_CAPlimit = ages [i];				done=1;			}			i++;		}   	   		// KILL OLD, STARTING WITH OLDEST		for(j=0; j < m_sizey; j++)   	 	{	        for(k=0; k < m_sizex;k++)   	     	{				if ((age [j] [k] > m_CAPlimit) && (age [j] [k] > m_OLD) && (to_kill > 0)) {					KillCell(j,k);					to_kill--;				}			}		}			if (to_kill > 0)			m_CAPlimit = ages [to_kill];		else			m_CAPlimit = 0;		// KILL YOUNG, STARTING WITH YOUNGEST		for(j=0; j < m_sizey; j++) {  	      for(k=0; k < m_sizex;k++) {				if ((age [j] [k] < m_CAPlimit) && (age [j] [k] < m_mature) && (to_kill > 0)) {					KillCell(j,k);					to_kill--;				}			}		}		// KILL PREGNANT, STARTING WITH OLDEST		for(j=0; j < m_sizey; j++) {      		for(k=0; k < m_sizex;k++) {				if ((sex [j] [k] >= 2) && (to_kill > 0)) {					KillCell(j,k);					to_kill--;				}			}		}	} else {  // NO EDGE EFFECT	(slower)		i=0;		int ageMAX = 0;				// FIND OLDEST.		for(j=0; j < m_sizey; j++)   	 	{	   	    for(k=0; k < m_sizex;k++)   		    {        	   	if (age [j] [k] > ageMAX)		   			ageMAX = age [j][k];			}    	}			int to_kill = i - m_CAPACITY - 1;		// KILL ELDERLY STARTING WITH OLDEST		while ((to_kill > 0)) {			j=0;			while ((j<m_sizey) && (to_kill > 0)) {				k=0;				while ((k<m_sizex) && (to_kill > 0)) {					if ((age [j] [k] >= ageMAX) && (age [j] [k] > m_OLD)) {						KillCell(j,k);						to_kill--;					}					k++;				}				j++;			}			ageMAX--;		}				int ageMIN=0;		// KILL YOUNG STARTING WITH YOUNGEST		while ((to_kill > 0) && (ageMIN < ageMAX)) {			j=0;			while ((j<m_sizey) && (to_kill > 0)) {				k=0;				while ((k<m_sizex) && (to_kill > 0)) {					if ((age [j] [k] < ageMIN) && (age [j] [k] < m_mature)) {						KillCell(j,k);						to_kill--;					}					k++;				}				j++;			}			ageMIN++;		}		// KILL PREGNANT, STARTING WITH OLDEST		while ((to_kill > 0) && (ageMAX > 0)) {			j=0;			while ((j<m_sizey) && (to_kill > 0) && (ageMAX > 0)) {				k=0;				while ((k<m_sizex) && (to_kill > 0) && (ageMAX > 0)) {					if ((age [j] [k] >= ageMAX) && (sex [j] [k] >= 2)) {						KillCell(j,k);						to_kill--;					}					k++;				}				j++;			}			ageMAX--;		}	}	Pop2ToPop();		for(j=0; j < m_sizey; j++)    {        for(k=0; k < m_sizex;k++)        {           	if (sex [j] [k] > 1) {           		if (sex [j] [k] == m_INCUBATION + 2)	// reset pregnant females  // increment for incubation period		   			sex [j] [k] = 0;				else					sex [j] [k]++;			}        	age [j][k]++;			// age the population by one turn        }    }}void CPopulationDlg::KillCell(int a,int b){//	MessageBox("In killcell");	pop2 [a] [b] = 0;	trait [a] [b] = "";	sex [a] [b] = -1;	age [a] [b] = 0;}void CPopulationDlg::GiveLife(int a,int b){//	MessageBox("in givelife");	int done = 0;	int Pxf;	int Pyf;	int Pxm;	int Pym;		// TODO: RANDOMIZE THE SELECTION PROCESS		// FIND MOTHER, MARK AS PREGNANT, GET COORDINATES.			if (a > 0)                if (((((pop [a-1] [b]) == 1) && (m_STERILE))                 	|| (((pop [a-1] [b]) > 0) && (!m_STERILE)))                 	&& (sex [a-1] [b] == 0) && (!done))				{					sex [a-1] [b] = 2;					Pyf = a-1;					Pxf = b;					done = 1;				}											           	if ((a > 0) && (b < (m_sizex-1)))                if( ((((pop [a-1] [b+1]) == 1) && (m_STERILE))                 	|| (((pop [a-1] [b+1]) > 0) && (!m_STERILE)))                 	&& (sex [a-1] [b+1] == 0) && (!done))				{					sex [a-1] [b+1] = 2;					Pyf = a-1;					Pxf = b+1;					done = 1;				}           	if (b > 0)                if( ((((pop [a] [b-1]) == 1) && (m_STERILE))                 	|| (((pop [a] [b-1]) > 0) && (!m_STERILE)))                 	&& (sex [a] [b-1] == 0) && (!done))				{					sex [a] [b-1] = 2;					Pyf = a;					Pxf = b-1;					done = 1;				}	            if ((b > 0) && (a < (m_sizey-1)))                if( ((((pop [a+1] [b-1]) == 1) && (m_STERILE))                 	|| (((pop [a+1] [b-1]) > 0) && (!m_STERILE)))                 	&& (sex [a+1] [b-1] == 0) && (!done))				{					sex [a+1] [b-1] = 2;					Pyf = a+1;					Pxf = b-1;					done = 1;				}   	        if (a < (m_sizey-1))                if( ((((pop [a+1] [b]) == 1) && (m_STERILE))                 	|| (((pop [a+1] [b]) > 0) && (!m_STERILE)))                	&& (sex [a+1] [b] == 0) && (!done))				{					sex [a+1] [b] = 2;					Pyf = a+1;					Pxf = b;					done = 1;				}            if ((a < (m_sizey-1)) && (b < (m_sizex-1)))                if( ((((pop [a+1] [b+1]) == 1) && (m_STERILE))                 	|| (((pop [a+1] [b+1]) > 0) && (!m_STERILE)))                 	&& (sex [a+1] [b+1] == 0) && (!done))				{					sex [a+1] [b+1] = 2;					Pyf = a+1;					Pxf = b+1;					done = 1;				}            if (b < (m_sizex-1))                if( ((((pop [a] [b+1]) == 1) && (m_STERILE))                 	|| (((pop [a] [b+1]) > 0) && (!m_STERILE)))                 	&& (sex [a] [b+1] == 0) && (!done))				{					sex [a] [b+1] = 2;					Pyf = a;					Pxf = b+1;					done = 1;				}			if ((a > 0) && (b > 0))				if(((((pop [a-1] [b-1]) == 1) && (m_STERILE))                		|| (((pop [a-1] [b-1]) > 0) && (!m_STERILE)))                	&& (sex [a-1] [b-1] == 0) && (!done))				{					sex [a-1] [b-1] = 2;					Pyf = a-1;					Pxf = b-1;					done = 1;				}		// FIND FATHER, GET COORDINATES.			done =0;			if (a > 0)                if( ((((pop [a-1] [b]) == 1) && (m_STERILE))                 	|| (((pop [a-1] [b]) > 0) && (!m_STERILE)))                 	&& (sex [a-1] [b] == 1) && (!done))				{					Pym = a-1;					Pxm = b;					done = 1;				}											           	if ((a > 0) && (b < (m_sizex-1)))                if( ((((pop [a-1] [b+1]) == 1) && (m_STERILE))                 	|| (((pop [a-1] [b+1]) > 0) && (!m_STERILE)))                 	&& (sex [a-1] [b+1] == 1) && (!done))				{					Pym = a-1;					Pxm = b+1;					done = 1;				}           	if (b > 0)                if( ((((pop [a] [b-1]) == 1) && (m_STERILE))                 	|| (((pop [a] [b-1]) > 0) && (!m_STERILE)))                 	&& (sex [a] [b-1] == 1) && (!done))				{					Pym = a;					Pxm = b-1;					done = 1;				}	            if ((b > 0) && (a < (m_sizey-1)))                if( ((((pop [a+1] [b-1]) == 1) && (m_STERILE))                 	|| (((pop [a+1] [b-1]) > 0) && (!m_STERILE)))                 	&& (sex [a+1] [b-1] == 1) && (!done))				{					Pym = a+1;					Pxm = b-1;					done = 1;				}   	        if (a < (m_sizey-1))                if( ((((pop [a+1] [b]) == 1) && (m_STERILE))                 	|| (((pop [a+1] [b]) > 0) && (!m_STERILE)))                 	&& (sex [a+1] [b] == 1) && (!done))				{					Pym = a+1;					Pxm = b;					done = 1;				}            if ((a < (m_sizey-1)) && (b < (m_sizex-1)))                if( ((((pop [a+1] [b+1]) == 1) && (m_STERILE))                 	|| (((pop [a+1] [b+1]) > 0) && (!m_STERILE)))                 	&& (sex [a+1] [b+1] == 1) && (!done))				{					Pym = a+1;					Pxm = b+1;					done = 1;				}            if (b < (m_sizex-1))                if( ((((pop [a] [b+1]) == 1) && (m_STERILE))                 	|| (((pop [a] [b+1]) > 0) && (!m_STERILE)))                 	&& (sex [a] [b+1] == 1) && (!done))				{					Pym = a;					Pxm = b+1;					done = 1;				}			if ((a > 0) && (b > 0))			if(((((pop [a-1] [b-1]) == 1) && (m_STERILE))             	|| (((pop [a-1] [b-1]) > 0) && (!m_STERILE)))             	&& (sex [a-1] [b-1] == 1) && (!done))			{				Pym = a-1;				Pxm = b-1;				done = 1;			}		// PUNNET SQUARE DETERMINES GENETIC MAKEUP		// test pick//		CString message = (CString) pun.pick("Rr","Rr").c_str();//		MessageBox("trait pick test == " + message);		CString message = (CString) trait [Pym] [Pxm].c_str() + " , " + (CString) trait [Pyf] [Pxf].c_str();//		MessageBox("trait before == " + message);		trait [a] [b] = pun.Cross((CString)trait [Pym] [Pxm].c_str(),(CString)trait [Pyf] [Pxf].c_str());		message = (CString) trait [a] [b].c_str();//		MessageBox("trait AFTER == " + message);		age [a] [b] = 0; // SET AGE TO ZERO				if (	islower(int(((CString) ((trait [a] [b]).substr(0,1)).c_str())[0])) 			&& 	islower(int(((CString) ((trait [a] [b]).substr(1,1)).c_str())[0])) ) {// recessive gene			pop2 [a] [b] = 2;//			MessageBox("pop = 2");		} else {//			MessageBox("pop = 1");					// carrier or healthy			pop2 [a] [b] = 1;					// do i need to add a pop2topop????		}		int random = rnd.RandInt(0,1);		if (random == 0)			sex [a] [b] = 1;		else			sex [a] [b] = 0;		if ((pop2 [a] [b] == 2) && ((m_DIEATBIRTH) || (m_KILLMOM)))	{			KillCell(a,b);			if (m_KILLMOM)				KillCell(Pyf,Pxm);		}}void CPopulationDlg::Pop2ToPop(){	for(int i=0;i<m_sizey;i++) {		for(int j=0;j<m_sizex;j++) {			pop [i] [j] = pop2 [i] [j];		}	}}void CPopulationDlg::MoveCells(){//	MessageBox("In movecells");	for(int i=0;i<m_sizey;i++) {		for(int j=0;j<m_sizex;j++) {			Move(i,j);		}	}	Pop2ToPop();//	MessageBox("Out movecells");}void CPopulationDlg::MoveInfo(int a,int b,int c,int d){	int swap=0;	apstring sswap="";	swap = age[a][b];	age[a][b]=0;	age[c][d]=swap;	swap = sex[a][b];	sex[a][b]=0;	sex[c][d]=swap;	sswap = trait[a][b];	trait[a][b]="";	trait[c][d]=swap;		pop2[c][d] = pop[a][b];}	    void CPopulationDlg::Move(int a,int b){	int r1 = rnd.RandInt(1,4);	int r2 = rnd.RandInt(0,4);	if (r2 > 2) // move cell	{		if ((r1 == 1) && (b > 0))		{			if (pop [a] [b-1] == 0)						   // add something to make them eat each other?				MoveInfo(a,b,a,b-1);		}		if ((r1 == 2) && (a < m_sizex))		{			if (pop [a+1] [b] == 0)				MoveInfo(a,b,a+1,b);		}		if ((r1 == 3) && (b < m_sizey))		{			if (pop [a] [b+1] == 0)				MoveInfo(a,b,a,b+1);		}		if ((r1 == 4) && (a > 0))		{			if (pop [a-1] [b] == 0)				MoveInfo(a-1,b,a,b);		}			} else 		pop2[a][b] = pop[a][b];}void CPopulationDlg::OnTimer(UINT nIDEvent) {//	MessageBox("Moving...");//	MoveCells();//	MessageBox("Updating...");	UpdatePop();//	MessageBox("drawing...");	DrawPop();//	MessageBox("Cycle done.");	UpdateVariables();	CDialog::OnTimer(nIDEvent);}void CPopulationDlg::OnFileStop() {	KillTimer(1);	}void CPopulationDlg::OnFileClear() {	ClearAll();}void CPopulationDlg::OnFileNext() {	if (m_RESTART)		OnFileRandomnew(); // add other ways for scenarios? no, maybe not.//	MessageBox("Moving...");//	MoveCells();//	MessageBox("Updating...");	UpdatePop();//	MessageBox("drawing...");	DrawPop();//	MessageBox("Cycle done.");	UpdateVariables();}void CPopulationDlg::UpdateVariables() {	m_total=0;	int i,j,k,t_age=0;		for(k=1;k<4;k++)		iGENO[k] = 0;	for(i=0;i<m_sizey;i++) {		for(j=0;j<m_sizex;j++) {			if (pop [i] [j] > 0) {				m_total++;				t_age += age [i] [j];			}				for(k=1;k<4;k++) {				if ((CString)trait [i] [j].c_str() == GENO[k])					iGENO[k]++;			}		}	}		m_TOTAL = m_total;	m_AVAGE = (double) ((100 * t_age) / m_total) / 100.0;  	m_GENO1 = GENO[1];	m_GENO2 = GENO[2];	m_GENO3 = GENO[3];	m_GENO1T = iGENO[1];	m_GENO2T = iGENO[2];	m_GENO3T = iGENO[3];	UpdateData(FALSE);}void CPopulationDlg::InitializeVariables() {	UpdateData(TRUE);	m_sizex = (int) sqrt(m_GRID);	m_sizey = (int) sqrt(m_GRID);	m_zoom = (int) (300 / (sqrt(m_GRID)));	m_counter = 0;	UpdateData(FALSE);}void CPopulationDlg::OnFileRandomnew() {	m_RESTART = FALSE;	InitializeVariables();	int rd,i,j;	ClearAll();	for(i=0;i<m_sizey;i++)	{		for(j=0;j<m_sizex;j++)		{			rd = rnd.RandInt(0,4);//			char change[5];//			itoa(rd,change,10);//			CString message = (CString) change;//			MessageBox("random == " + message);			if (rd == 2)			{				pop[i] [j] = 1;				pop2[i] [j] = 1;				rd = rnd.RandInt(0,1);				sex[i][j]=rd;				age[i][j]=0;	  // TODO: RANDOMIZE.				rd = rnd.RandInt(1,4);				if (rd == 1)  			// recessive		// if hardy weinberg.					trait[i][j]="rr";				else if (rd == 4)		// dominant					trait[i][j]="RR";				else 					// carrier					trait[i][j]="Rr";			} else			{				pop[i] [j] = 0;				pop2[i] [j] = 0;			}		}	}	GENO[1] = "RR";		  // hardy weinberg secenario	GENO[2] = "Rr";	GENO[3] = "rr";	iGENO[1] = 0;	iGENO[2] = 0;	iGENO[3] = 0;	UpdateVariables();	UpdateData(FALSE);	if (m_grid == TRUE)		DrawGrid();	DrawPop();}void CPopulationDlg::OnActionGridoff() {	m_grid = FALSE;	}void CPopulationDlg::OnActionGridon() {	m_grid = TRUE;}void CPopulationDlg::Swap(int & a,int & b)// generic swap routine{	int temp = a;	a = b;	b = temp;}int CPopulationDlg::Pivot(int first,int last)// postcondition: returns piv such that//				first <= k <= piv, a[k] <= a[piv]//				piv < k <= last, a[piv] < a[k]{	int k,p=first;	int piv;	piv = ages[first];		// first element is pivot	for(k=first+1;k<=last;k++)	{		if (ages[k] <= piv) // belongs in first half		{			p++; // p now indexes greater half			Swap(ages[k],ages[p]);	// swap smaller and greater		}	}	Swap(ages[p],ages[first]);	// put pivot in proper location	return p;}void CPopulationDlg::Quick(int first,int last)// postcondition: ages[first <= ... <= ages[last]{	int piv;	if (first < last)	{		piv = Pivot(first,last);		// find pivot and divide vector		Quick(first,piv-1);			// sort first half		Quick(piv+1,last);			// sort other half	}}void CPopulationDlg::QSort(int size)// precondition:size = # of elements of ages// postcondition: ages is sorted{	Quick(0,size-1);}void CPopulationDlg::SSort(int numElts)// precondition: ages contains numElts// postcondition: elements of ages are sorted in nondecreasing order{	int j,k,minIndex;	for(k=0;k<numElts-1;k++)	{		minIndex = k;  // smallest itemfrom k to end of ages		for(j=k+1;j<numElts;j++)		{			if(ages[j]<ages[minIndex])				minIndex = j;	// new smallest item, remember where		}		Swap(ages[k],ages[minIndex]); // swap smallest item and kth item	}}void CPopulationDlg::OnViewShowtotal() {			char change[5];			itoa(m_total,change,10);			CString message = (CString) change;			MessageBox("Total: " + message);}void CPopulationDlg::OnButtonNext() {	OnFileNext();}void CPopulationDlg::OnButtonStop() {	OnFileStop();	}void CPopulationDlg::OnButtonGo() {	OnFileGo();	}void CPopulationDlg::OnMigration() {	m_MOVE = !m_MOVE;	UpdateData(FALSE);	}void CPopulationDlg::OnChangeEditGridSize() {	if (m_RESTART=FALSE) {		m_RESTART = TRUE;		ClearAll();	}	UpdateData(TRUE);	}void CPopulationDlg::OnGrid() {	m_GRID = !m_GRID;	ClearAll();		if (m_GRID)		DrawGrid();		UpdateData(FALSE);	}void CPopulationDlg::OnChangeEditCapacity() {	UpdateData(TRUE);}void CPopulationDlg::OnChangeEditMature() {	UpdateData(TRUE);}void CPopulationDlg::OnChangeEditLifespan() {	UpdateData(TRUE);}void CPopulationDlg::OnKillMom() {	m_KILLMOM = TRUE;	m_NODIFFERENT = FALSE;	m_STERILE = FALSE;	m_DIEATBIRTH = FALSE;	m_DIEAFTER = FALSE;	UpdateData(FALSE);	}void CPopulationDlg::OnNodifferent() {	m_KILLMOM = FALSE;	m_NODIFFERENT = TRUE;	m_STERILE = FALSE;	m_DIEATBIRTH = FALSE;	m_DIEAFTER = FALSE;		UpdateData(FALSE);	}void CPopulationDlg::OnSterile() {	m_KILLMOM = FALSE;	m_NODIFFERENT = FALSE;	m_STERILE = TRUE;	m_DIEATBIRTH = FALSE;	m_DIEAFTER = FALSE;		UpdateData(FALSE);	}void CPopulationDlg::OnChangeEditRecDie() {	UpdateData(TRUE);	}void CPopulationDlg::OnDieAtBirth() {	m_KILLMOM = FALSE;	m_NODIFFERENT = FALSE;	m_STERILE = FALSE;	m_DIEATBIRTH = TRUE;	m_DIEAFTER = FALSE;		UpdateData(FALSE);	}void CPopulationDlg::OnDieAfter() {	m_KILLMOM = FALSE;	m_NODIFFERENT = FALSE;	m_STERILE = FALSE;	m_DIEATBIRTH = FALSE;	m_DIEAFTER = TRUE;		UpdateData(FALSE);	}void CPopulationDlg::OnChangeEditOld() {	UpdateData(TRUE);	}void CPopulationDlg::OnEdge() {	m_EDGE = ! m_EDGE;	UpdateData(FALSE);	}void CPopulationDlg::OnChangeEditIncubation() {	UpdateData(TRUE);	}></pre></body></html